I"ö<h1 id="c-byteæµå’Œå­—ç¬¦ä¸²æ–‡ä»¶ç¼–è§£ç ">C++ byteæµå’Œå­—ç¬¦ä¸²æ–‡ä»¶ç¼–è§£ç </h1>

<hr />
<p><em>å‚è€ƒé“¾æ¥<a href="https://blog.csdn.net/sunflover454/article/details/53885419">C++ urlç¼–è§£ç ç±»</a></em></p>

<blockquote>
  <p>2019-4-11 :00:10:12 ;åœ¨åˆ·leetcodeçš„535é¢˜æ—¶è”æƒ³åˆ°äº†C++ byteç¼–ç å’Œfile stringçš„å­—ç¬¦ç¼–ç é—®é¢˜ï¼Œå› æ­¤å¼€è¿™ç¯‡æ–‡ç« å¸Œæœ›èƒ½å°½é‡è§£å†³ï¼Œ</p>
</blockquote>

<p>ä¸‹é¢æ˜¯ç®€å•çš„C++ url UTF-8å’ŒGKBçš„ç¼–è§£ç å®ç°</p>

<p><code class="language-plaintext highlighter-rouge">UrlConvert.h</code>å¤´æ–‡ä»¶å®šä¹‰ï¼š</p>
<pre><code class="language-C++">//UrlConvert.h
#ifndef __URLCONVERT_H__
#define __URLCONVERT_H__
#pragma once
/*
ä½¿ç”¨æ–¹æ³•ï¼š
CUrlConvert url;
//Encode test
string str1 = url.UrlEncode_GBK("è°·å§");
cout &lt;&lt; "UrlEncode_GBK " &lt;&lt; str1.c_str() &lt;&lt;endl;
string str2 = url.UrlEncode_UTF8("è°·å§");
cout &lt;&lt; "UrlEncode_UTF8 " &lt;&lt; str2.c_str() &lt;&lt;endl;
//Decode test
string str3 = url.UrlDecode_GBK(str1);
cout &lt;&lt; "UrlDecode_GBK " &lt;&lt; str3.c_str() &lt;&lt;endl;
string str4 = url.UrlDecode_UTF8(str2);
cout &lt;&lt; "UrlDecode_UTF8 " &lt;&lt; str4.c_str() &lt;&lt;endl;
*/
#include &lt;Windows.h&gt;
#include &lt;string&gt;
 
class CUrlConvert
{
public:
	CUrlConvert(void);
	~CUrlConvert(void);
 
	// URLç¼–ç ï¼Œç¼–ç ä¸ºGBK
	std::string UrlEncode_GBK(std::string strOrg);
	// URLç¼–ç ï¼Œç¼–ç ä¸ºUTF-8
	std::string UrlEncode_UTF8(std::string strOrg);
 
	// URLè§£ç ï¼Œè§£ç ä¸ºGBK
	std::string UrlDecode_GBK(std::string strOrg);
	// URLè§£ç ï¼Œè§£ç ä¸ºUTF-8
	std::string UrlDecode_UTF8(std::string strOrg);
 
private:
	// URLè§£ç ï¼Œè§£ç ä¸ºGBK
	std::string URLDecode(std::string&amp; strOrg);
	// URLç¼–ç ï¼Œç¼–ç ä¸ºGBK
	std::string URLEncode(std::string&amp; strOrg);
 
	std::string GBKToUTF8(const std::string &amp;strGBK);
	std::string UTF8ToGBK(const std::string &amp;strUTF8);
};
 
#endif //__URLCONVERT_H__
</code></pre>
<hr />

<p><code class="language-plaintext highlighter-rouge">UrlConvert.cpp</code>å®ç°æ–‡ä»¶å¦‚ä¸‹ï¼š</p>
<pre><code class="language-C++">//UrlConvert.cpp
#include "UrlConvert.h"
 
byte toHex(const byte &amp;x)  
{  
	return x &gt; 9 ? x -10 + 'A': x + '0';  
}  
 
byte fromHex(const byte &amp;x)  
{  
	return isdigit(x) ? x-'0' : x-'A'+10;  
} 
 
CUrlConvert::CUrlConvert(void)
{
}
 
 
CUrlConvert::~CUrlConvert(void)
{
}
 
// URLè§£ç ï¼Œè§£ç ä¸ºGBK
std::string CUrlConvert::URLDecode(std::string&amp; strOrg)
{
	std::string sOut;  
	for( size_t ix = 0; ix &lt; strOrg.size(); ix++ )  
	{  
		byte ch = 0;  
		if(strOrg[ix]=='%')  
		{  
			ch = (fromHex(strOrg[ix+1])&lt;&lt;4);  
			ch |= fromHex(strOrg[ix+2]);  
			ix += 2;  
		}  
		else if(strOrg[ix] == '+')  
		{  
			ch = ' ';  
		}  
		else  
		{  
			ch = strOrg[ix];  
		}  
		sOut += (char)ch;  
	}  
	return sOut;
}
 
// URLç¼–ç ï¼Œç¼–ç ä¸ºGBK
std::string CUrlConvert::URLEncode(std::string&amp; strOrg)
{
	std::string sOut;  
	for( size_t ix = 0; ix &lt; strOrg.size(); ix++ )  
	{        
		byte buf[4];  
		memset( buf, 0, 4 );  
		if( isalnum( (byte)strOrg[ix] ) )  
		{        
			buf[0] = strOrg[ix];  
		}  
		//else if ( isspace( (byte)strOrg[ix] ) ) //è²Œä¼¼æŠŠç©ºæ ¼ç¼–ç æˆ%20æˆ–è€…+éƒ½å¯ä»¥  
		//{  
		//    buf[0] = '+';  
		//}  
		else  
		{  
			buf[0] = '%';  
			buf[1] = toHex( (byte)strOrg[ix] &gt;&gt; 4 );  
			buf[2] = toHex( (byte)strOrg[ix] % 16);  
		}  
		sOut += (char *)buf;  
	}  
	return sOut;
}
 
std::string CUrlConvert::GBKToUTF8(const std::string &amp;strGBK)
{
	std::string strOutUTF8 = "";
	int n = MultiByteToWideChar(CP_ACP, 0, strGBK.c_str(),  - 1, NULL, 0);
	wchar_t *str1 = new wchar_t[n];
	MultiByteToWideChar(CP_ACP, 0, strGBK.c_str(),  - 1, str1, n);
	n = WideCharToMultiByte(CP_UTF8, 0, str1,  - 1, NULL, 0, NULL, NULL);
	char *str2 = new char[n];
	WideCharToMultiByte(CP_UTF8, 0, str1,  - 1, str2, n, NULL, NULL);
	strOutUTF8 = str2;
	delete [] str1;
	delete [] str2;
	return strOutUTF8;
}
 
std::string CUrlConvert::UTF8ToGBK(const std::string &amp;strUTF8)
{
	int len = MultiByteToWideChar(CP_UTF8, 0, strUTF8.c_str(),  - 1, NULL, 0);
	wchar_t *wszGBK = new wchar_t[len + 1];
	memset(wszGBK, 0, (len+1)*sizeof(WCHAR));
	MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)strUTF8.c_str(),  - 1, wszGBK, len);
	len = WideCharToMultiByte(CP_ACP, 0, wszGBK,  - 1, NULL, 0, NULL, NULL);
	char *szGBK = new char[len + 1];
	memset(szGBK, 0, len + 1);
	WideCharToMultiByte(CP_ACP, 0, wszGBK,  - 1, szGBK, len, NULL, NULL);
	//strUTF8 = szGBK;
	std::string strTemp(szGBK);
	delete [] szGBK;
	delete [] wszGBK;
	return strTemp;
}
 
// URLç¼–ç ï¼Œç¼–ç ä¸ºGBK
std::string CUrlConvert::UrlEncode_GBK(std::string strOrg)
{
	return URLEncode(strOrg);
}
 
// URLç¼–ç ï¼Œç¼–ç ä¸ºUTF-8
std::string CUrlConvert::UrlEncode_UTF8(std::string strOrg)
{
	return URLEncode(GBKToUTF8(strOrg));
}
 
// URLè§£ç ï¼Œè§£ç ä¸ºGBK
std::string CUrlConvert::UrlDecode_GBK(std::string strOrg)
{
	return URLDecode(strOrg);
}
 
// URLè§£ç ï¼Œè§£ç ä¸ºUTF-8
std::string CUrlConvert::UrlDecode_UTF8(std::string strOrg)
{
	return UTF8ToGBK(URLDecode(strOrg));
}
</code></pre>
:ET