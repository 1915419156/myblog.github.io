I"p<blockquote>
  <blockquote>
    <p>2019-5-12 :19:44:52</p>
  </blockquote>
</blockquote>

<h2 id="泛型算法">泛型算法</h2>

<p>泛型算法是指使用迭代器为媒介的通用型算法；泛型算法本身不会执行容器的操作，他们只会运行于迭代器智商，执行迭代器的操作–算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素值。</p>

<p><strong><code class="language-plaintext highlighter-rouge">accumulate</code> 求和</strong></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span><span class="n">accumulate</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="mi">0</span><span class="p">);</span><span class="c1">//对元素求和初值是0</span>

<span class="n">string</span> <span class="n">sum</span><span class="o">=</span><span class="n">accumulate</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">v</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">string</span><span class="p">(</span><span class="err">''</span><span class="p">));</span><span class="c1">//字符串求和</span>

<span class="n">equal</span><span class="p">(</span><span class="n">roster1</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">roster1</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">rosterl2</span><span class="p">.</span><span class="n">cbegin</span><span class="p">());</span><span class="c1">//比较元素，数量相同且一样多的时候才返回`true`</span>

<span class="n">fill</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span><span class="c1">//将容器的一个子序列设置为10</span>

<span class="n">back_inserter</span><span class="p">();</span><span class="c1">//插入元素，检查是否存在</span>

<span class="n">copy</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span><span class="n">end</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span><span class="n">a2</span><span class="p">);</span><span class="c1">//把a1的内容拷贝给a2</span>

<span class="n">replace</span><span class="p">(</span><span class="n">ilist</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">ilist</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p">);</span><span class="c1">//查找所有元素为0的值，并将它更改为42</span>

<span class="n">replace_copy</span><span class="p">(</span><span class="n">ilis</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">ilist</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">ivec</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="mi">42</span><span class="p">);</span><span class="c1">//ilist指出调整序列之后的保存位置。</span>

<span class="n">sort</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">word</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//按照字典排序</span>

<span class="k">auto</span> <span class="n">end_unique</span><span class="o">=</span><span class="n">unique</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">());</span><span class="c1">//除去重复单词</span>

</code></pre></div></div>

<p>注意：</p>

<ul>
  <li>算法不检查写操作</li>
  <li>向目的位置迭代器写入数据的算法，假定目的位置足够大，能容纳要写入的元素。</li>
</ul>

<h3 id="定制操作">定制操作</h3>
<p>许多算法的默认关键操作符，并不能满足我们的需求，因此，需要我们来重载<code class="language-plaintext highlighter-rouge">sort</code>的默认行为。</p>

<h4 id="向算法传递函数">向算法传递函数</h4>
<p>sort可以接受第三个参数，即谓词–一个可用的表达式，其返回结果是一个能用作条件的值。标准库中分为
<strong>一元谓词</strong>(只接受单一参数)和<strong>二元谓词</strong>(他们有两个参数)。例如下面的代码，重载了sort函数的基础比较操作</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//排序函数</span>

<span class="kt">bool</span> <span class="nf">isShorter</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s1</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&lt;</span><span class="n">s2</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">//按照长度由短到长排序</span>
<span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">isShorter</span><span class="p">);</span>

<span class="n">elimDups</span><span class="p">(</span><span class="n">words</span><span class="p">);</span><span class="c1">//将words按照字典重新排序，并消除重复单词</span>

<span class="n">stable_sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">isShorter</span><span class="p">)</span><span class="err">；</span><span class="c1">//按照长度重新排序，长度相同的单词维持字典序</span>

<span class="c1">//无需拷贝字符串</span>

<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">s</span> <span class="o">:</span><span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="s">""</span><span class="p">;</span><span class="c1">//打印每个元素，以空格分割</span>

<span class="p">}</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>

</code></pre></div></div>
<h3 id="lambda-表达式">lambda 表达式</h3>

<p><em>参考链接：</em> <a href="https://www.cnblogs.com/DswCnblog/p/5629165.html">c++11 lambda 表达式</a>;<a href="https://www.cnblogs.com/jimodetiantang/p/9016826.html">c++ lambda表达式</a>;</p>

<p><strong>lambda表达式的声明</strong></p>

<p><code class="language-plaintext highlighter-rouge">[capture list] (params list) mutable exception-&gt; return type { function body }</code>
各项含义如下：</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">capture list</code>: 捕获外部变量列表</li>
  <li><code class="language-plaintext highlighter-rouge">params list</code>: 形参列表</li>
  <li><code class="language-plaintext highlighter-rouge">mutable</code>:用来说明是否可以修改捕获的变量</li>
  <li><code class="language-plaintext highlighter-rouge">exception</code>:异常设定</li>
  <li><code class="language-plaintext highlighter-rouge">return type</code>:返回类型</li>
  <li><code class="language-plaintext highlighter-rouge">function body</code>:函数体</li>
</ol>

<p>省略的常见表达式有：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">序号</th>
      <th style="text-align: left">格式</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">1</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[capture list] (params list) -&gt; return type {function body}</code></td>
    </tr>
    <tr>
      <td style="text-align: left">2</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[capture list] (params list) {function body}</code></td>
    </tr>
    <tr>
      <td style="text-align: left">3</td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[capture list] {function body}</code></td>
    </tr>
  </tbody>
</table>

<p>其中：</p>

<ul>
  <li>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</li>
  <li>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</li>
  <li>格式3中省略了参数列表，类似普通函数中的无参函数。</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span>  <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">myvec</span><span class="p">{</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span> <span class="p">};</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lbvec</span><span class="p">(</span><span class="n">myvec</span><span class="p">);</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">myvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span> <span class="c1">// 旧式做法</span>

    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"predicate function:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">it</span> <span class="o">:</span> <span class="n">myvec</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>

    <span class="n">sort</span><span class="p">(</span><span class="n">lbvec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">lbvec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">;</span> <span class="p">});</span>   <span class="c1">// Lambda表达式</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"lambda expression:"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">it</span> <span class="o">:</span> <span class="n">lbvec</span><span class="p">)</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>lambde表达式的外部捕获</p>

<p>Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p>

<p>值捕获方式：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">捕获形式</th>
      <th style="text-align: left">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[]</code></td>
      <td style="text-align: left">不捕获任何外部变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[变量名, …]</code></td>
      <td style="text-align: left">默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[this]</code></td>
      <td style="text-align: left">以值的形式捕获this指针</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[=]</code></td>
      <td style="text-align: left">以值的形式捕获所有外部变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[&amp;]</code></td>
      <td style="text-align: left">以引用形式捕获所有外部变量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[=, &amp;x]</code></td>
      <td style="text-align: left">变量x以引用形式捕获，其余变量以传值形式捕获</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">[&amp;, x] </code></td>
      <td style="text-align: left">变量x以值的形式捕获，其余变量以引用形式捕获</td>
    </tr>
  </tbody>
</table>

<p>注意：如果一个lambda体包含<code class="language-plaintext highlighter-rouge">return</code>之外的任何语句，则编译器假定lambda返回<code class="language-plaintext highlighter-rouge">void</code>；被推断<code class="language-plaintext highlighter-rouge">void</code>的lambda不能返回值。因此当重写排序等操作的时候，只能有一句<code class="language-plaintext highlighter-rouge">return</code>语句；例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">?-</span><span class="n">i</span><span class="o">:</span><span class="n">i</span><span class="p">;</span><span class="c1">//返回绝对值</span>

    <span class="p">});</span>

<span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//错误，有多余语句，判定返回void</span>

    <span class="p">});</span>

</code></pre></div></div>

<p>因此当我们使用一个lambda定义返回类型的时候，必须使用尾置返回类型，声明返回类型；例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">transform</span><span class="p">(</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">vi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
    <span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="kt">int</span> 
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">//返回绝对值</span>

    <span class="p">});</span>
</code></pre></div></div>

<h4 id="lambda-参数绑定">lambda 参数绑定</h4>
<p>lambda表达式，虽然可以进行简单的参数绑定，但是对于复杂的参数绑定而言，还是存在许多问题，因此可以利用函数对lambda表达式进行参数绑定。大致步骤如下：</p>

<ol>
  <li>使用<code class="language-plaintext highlighter-rouge">std:bind</code>函数对函数参数和函数进行绑定</li>
  <li>使用<code class="language-plaintext highlighter-rouge">placeholderd</code>进行参数占位符的使用。</li>
</ol>

<p>调用<code class="language-plaintext highlighter-rouge">bind</code>一般形式为：
<code class="language-plaintext highlighter-rouge">auto newCallable=bind(callable,arg_list);</code></p>

<p><code class="language-plaintext highlighter-rouge">newCallable</code>本身是一个可以调用对象，<code class="language-plaintext highlighter-rouge">arg_list</code>是一个逗号分隔的参数列表，对应给定的<code class="language-plaintext highlighter-rouge">callable</code>的参数，即调用的实际参数。
<code class="language-plaintext highlighter-rouge">arg_list</code>中的参数可能包含形如<code class="language-plaintext highlighter-rouge">_n</code>的名字，其中<code class="language-plaintext highlighter-rouge">n</code>是一个整数。表示占位符，数值<code class="language-plaintext highlighter-rouge">n</code>表示生成的可调用对象中参数的位置：<code class="language-plaintext highlighter-rouge">_1</code>为<code class="language-plaintext highlighter-rouge">newCallble</code>的第一个参数，<code class="language-plaintext highlighter-rouge">_2</code>为第二个参数。<code class="language-plaintext highlighter-rouge">_n</code>为第<code class="language-plaintext highlighter-rouge">n</code>个参数。
使用：
<code class="language-plaintext highlighter-rouge">auto g=bind(f,a,b,_2,c,_1);</code>
生成一个新的可调用函数对象，它有两个参数，分别使用占位符<code class="language-plaintext highlighter-rouge">_2</code>和<code class="language-plaintext highlighter-rouge">_1</code>表示。使得原本需要输入5个参数的函数变为，只需要2个参数的函数，对函数进行了再一次封装。<code class="language-plaintext highlighter-rouge">f(a,b,_1,c,_2)</code>等价于<code class="language-plaintext highlighter-rouge">g(_1,_2)</code>减少了函数的复杂程度。</p>

<p><code class="language-plaintext highlighter-rouge">std::ref()</code>：传递给<code class="language-plaintext highlighter-rouge">bind</code>一个对象但是不拷贝它</p>

<p>例如：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//1. 定义比较string大小函数</span>

<span class="kt">bool</span> <span class="nf">check_size</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">sz</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">&gt;=</span><span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//2. 使用bind绑定函数和参数</span>
<span class="c1">//将输入比较顺序颠倒，将单词长度由长至短排序</span>

<span class="n">sort</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="n">bind</span><span class="p">(</span><span class="n">isShorter</span><span class="p">,</span><span class="n">_2</span><span class="p">,</span><span class="n">_1</span><span class="p">));</span>

<span class="c1">//使用lambda表达式，输出表达式，os是一个局部变量，引用一个输出流</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">word</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),[</span><span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="n">c</span><span class="p">](</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">){</span>
    <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">//bind相同的效果 </span>

<span class="n">ostream</span> <span class="o">&amp;</span><span class="n">print</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span><span class="k">const</span> <span class="n">string</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">,</span><span class="kt">char</span> <span class="n">c</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">&lt;&lt;</span><span class="n">s</span><span class="o">&lt;&lt;</span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//ref返回一个对象，包含给定的引用，此对象是可以拷贝的</span>

<span class="n">for_each</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">words</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
        <span class="n">bind</span><span class="p">(</span><span class="n">print</span><span class="p">,</span><span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">os</span><span class="p">),</span><span class="n">_1</span><span class="p">,</span><span class="sc">' '</span><span class="p">));</span>


</code></pre></div></div>

<h4 id="再探迭代器">再探迭代器</h4>

<h5 id="插入迭代器">插入迭代器</h5>
<p>插入迭代器有三种基本类型</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">back_inserter</code>: 创建一个使用<code class="language-plaintext highlighter-rouge">push_back</code>的迭代器。</li>
  <li><code class="language-plaintext highlighter-rouge">front_inserter</code>:创建一个使用<code class="language-plaintext highlighter-rouge">push_front</code>的迭代器。</li>
  <li><code class="language-plaintext highlighter-rouge">inserter</code>:创建一个使用<code class="language-plaintext highlighter-rouge">inserter</code>的迭代器。此函数接受第二个参数，这个参数必须是一个指向容器的迭代器。元素将被插入到给定迭代器所表示的元素制之前。</li>
</ul>

<p>注意： 只有在容器支持<code class="language-plaintext highlighter-rouge">push_front/push_back</code>的情况下，我们才可以使用<code class="language-plaintext highlighter-rouge">front_inserter/back_inserter</code>。</p>

<p>使用示例：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">*</span><span class="n">it</span><span class="o">=</span><span class="n">val</span><span class="p">;</span>
<span class="n">it</span><span class="o">=</span><span class="n">c</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">it</span><span class="p">,</span><span class="n">val</span><span class="p">);</span><span class="c1">//it指向插入的新元素</span>

<span class="o">++</span><span class="n">it</span><span class="p">;</span><span class="c1">//递增it使它指向原来的元素</span>

<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst</span><span class="o">=</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">};</span>
<span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lst2</span><span class="err">，</span><span class="n">lst3</span><span class="p">;</span><span class="c1">//空list</span>
<span class="c1">//拷贝完成之后，lst3包含1 2 3 4</span>

<span class="n">copy</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">lst</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">front_inserter</span><span class="p">(</span><span class="n">lst2</span><span class="p">));</span>
<span class="c1">//拷贝完成之后，lst3包含1 2 3 4</span>

<span class="n">copy</span><span class="p">(</span><span class="n">lst</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">lst</span><span class="p">.</span><span class="n">cend</span><span class="p">(),</span><span class="n">inserter</span><span class="p">(</span><span class="n">lst3</span><span class="p">,</span><span class="n">lst3</span><span class="p">.</span><span class="n">begin</span><span class="p">()));</span>

</code></pre></div></div>

<h5 id="iostream-迭代器">iostream 迭代器</h5>

<ul>
  <li><code class="language-plaintext highlighter-rouge">istream_iterator</code>:读取输入流。</li>
  <li><code class="language-plaintext highlighter-rouge">ostream_iterator</code>:向输出流写数据。</li>
</ul>

<p><strong><code class="language-plaintext highlighter-rouge">istream_iterator</code>操作</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">istream_iterator&lt;T&gt; in(is)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">in</code>从输入流<code class="language-plaintext highlighter-rouge">is</code>读取类型为<code class="language-plaintext highlighter-rouge">T</code>的值</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">istream_iterator&lt;T&gt; end</code></td>
      <td style="text-align: left">读取类型为<code class="language-plaintext highlighter-rouge">T</code>的值的<code class="language-plaintext highlighter-rouge">istream_iterator</code>迭代器，表示尾后位置</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">in1=(!)=in2</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">in1</code>和<code class="language-plaintext highlighter-rouge">in2</code>必须读取相同类型。如果他们都是尾后迭代器，或绑定到相同输入，则二者相等</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">*in</code></td>
      <td style="text-align: left">返回从流中读取的值</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">in-&gt;mem</code></td>
      <td style="text-align: left">与<code class="language-plaintext highlighter-rouge">(*in).mem</code>的含义相同</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">++in,in++</code></td>
      <td style="text-align: left">使用元素类型所定义的<code class="language-plaintext highlighter-rouge">&gt;&gt;</code>运算符从输入流中读取下一个值，并且前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td>
    </tr>
  </tbody>
</table>

<p>操作示例：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">&gt;</span> <span class="n">int_it</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span> <span class="c1">//从cin读取int</span>

<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">int_eof</span><span class="p">;</span> <span class="c1">//尾后迭代器</span>

<span class="n">ifstream</span> <span class="nf">in</span><span class="p">(</span><span class="s">"afile"</span><span class="p">);</span>  
<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">str_it</span><span class="p">(</span><span class="n">in</span><span class="p">);</span> <span class="c1">//从"afile"读取字符串</span>

<span class="c1">//读入数据并存储到vector向量组</span>

<span class="k">while</span><span class="p">(</span><span class="n">int_it</span><span class="o">!=</span><span class="n">eof</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//后置递增运算读取流，返回迭代器的旧值</span>
    <span class="c1">//解引用迭代器，获得从流读取的前一个值</span>

    <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">in_iter</span><span class="o">++</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//循环读取其中的int值存储在vec中</span>

<span class="c1">//使用算法操作流迭代器</span>

<span class="n">istream_iterator</span><span class="o">&lt;</span><span class="kt">int</span> <span class="o">&gt;</span> <span class="n">in</span><span class="p">(</span><span class="n">cin</span><span class="p">),</span><span class="n">eof</span><span class="p">;</span>
<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">accumulate</span><span class="p">(</span><span class="n">in</span><span class="p">,</span><span class="n">eof</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span>
<span class="c1">//输入：23 109 45 89 6 34 12 90 34 23 56 23 8 89 23</span>

<span class="c1">//输出：664</span>


</code></pre></div></div>
<p>注意：当我们将一个<code class="language-plaintext highlighter-rouge">istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流中读取数据。直到使用迭代器时才正真读取。标准库中的实现所保证的是，我们第一次解引用迭代器之前，从六中的数据操作已经完成了。</p>

<h5 id="ostream_iterator操作"><code class="language-plaintext highlighter-rouge">ostream_iterator</code>操作</h5>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ostream_iterator&lt;T&gt; out(os)</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">out</code>将类型为<code class="language-plaintext highlighter-rouge">T</code>的值写入到流<code class="language-plaintext highlighter-rouge">os</code>中</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">ostream_iterator&lt;T&gt; out(os,d)</code></td>
      <td style="text-align: left">将类型为<code class="language-plaintext highlighter-rouge">T</code>的值写到输出流<code class="language-plaintext highlighter-rouge">os</code>中，每个值后面都输出一个<code class="language-plaintext highlighter-rouge">d</code>。<code class="language-plaintext highlighter-rouge">d</code>指向一个空字符结尾的字符数组</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">out=val</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">out</code>和<code class="language-plaintext highlighter-rouge">val</code>必须类型兼容。用运算符<code class="language-plaintext highlighter-rouge">&lt;&lt;</code>将<code class="language-plaintext highlighter-rouge">val</code>写入到<code class="language-plaintext highlighter-rouge">out</code>输出流中</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">*out,++out,out++</code></td>
      <td style="text-align: left">这些运算符是存在的，但是不对<code class="language-plaintext highlighter-rouge">out</code>做任何事情。每个运算符都返回<code class="language-plaintext highlighter-rouge">out</code></td>
    </tr>
  </tbody>
</table>

<h3 id="泛型算法结构">泛型算法结构</h3>
<p>对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或者提示。因此需要迭代器类型的支持和认证。</p>

<p><strong>迭代器类别</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">类别</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">输入迭代器</td>
      <td style="text-align: left">只读，不写；单遍扫描，只能递增</td>
    </tr>
    <tr>
      <td style="text-align: left">输出迭代器</td>
      <td style="text-align: left">只写，不读；单遍扫描，只能递增</td>
    </tr>
    <tr>
      <td style="text-align: left">前向迭代器</td>
      <td style="text-align: left">可读写；多遍扫描，只能递增</td>
    </tr>
    <tr>
      <td style="text-align: left">双向迭代器</td>
      <td style="text-align: left">可读写；多遍扫描，可递增递减</td>
    </tr>
    <tr>
      <td style="text-align: left">随机访问迭代器</td>
      <td style="text-align: left">可读写；多遍扫描，支持全部迭代运算</td>
    </tr>
  </tbody>
</table>

<h2 id="第11章-关联容器">第11章 关联容器</h2>

<p>关联容器支持高效的关键字查找和访问。两个主要的关联容器类型是<code class="language-plaintext highlighter-rouge">map</code>和<code class="language-plaintext highlighter-rouge">set</code>；关联容器不支持顺序容器的位置相关的操作。也不支持构造函数或者插入操作这些接受一个元素值和一个数量值的操作。</p>

<p>使用示例：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">;</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span><span class="c1">//空容器</span>

<span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">exclude</span><span class="o">=</span><span class="p">{</span><span class="s">"the"</span><span class="p">,</span><span class="s">"but"</span><span class="p">,</span><span class="s">"and"</span><span class="p">,</span><span class="s">"or"</span><span class="p">,</span><span class="s">"an"</span><span class="p">,</span><span class="s">"a"</span><span class="p">};</span>

<span class="c1">//三个元素；authors将姓映射为名</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">authors</span><span class="o">=</span><span class="p">{</span>
    <span class="p">{</span><span class="s">"Joyce"</span><span class="p">,</span><span class="s">"James"</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"Austen"</span><span class="p">,</span><span class="s">"Jane"</span><span class="p">},</span>
    <span class="p">{</span><span class="s">"Dickens"</span><span class="p">,</span><span class="s">"Charles"</span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>注意：一个<code class="language-plaintext highlighter-rouge">map</code>或者<code class="language-plaintext highlighter-rouge">set</code>中的关键字必须是唯一的。但是<code class="language-plaintext highlighter-rouge">multimap</code>和<code class="language-plaintext highlighter-rouge">multiset</code>没有这个限制。允许多个元素，拥有相同的关键字。</p>

<h4 id="1122-关键字类型要求">11.2.2 关键字类型要求</h4>
<p>传递给排序算法的可调用对象，必须满足于关联容器中关键字一样的类型要求。</p>

<h4 id="1123-pair类型">11.2.3 <code class="language-plaintext highlighter-rouge">pair</code>类型</h4>

<p><code class="language-plaintext highlighter-rouge">pair</code>主要保存，两个数据成员，必须提供2个类型名，<code class="language-plaintext highlighter-rouge">pair</code>的数据成员，将具有应对的类型。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="n">string</span> <span class="o">&gt;</span> <span class="n">anon</span><span class="p">;</span> <span class="c1">//保存两个string</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span> <span class="c1">//保存一个string和一个size_t</span>

<span class="n">pair</span><span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">line</span><span class="p">;</span> <span class="c1">//保存string和vector&lt;int&gt;</span>

</code></pre></div></div>

<p><strong><code class="language-plaintext highlighter-rouge">pair</code>上的操作</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">pair &lt;T1,T2&gt; p</code></td>
      <td style="text-align: left">p是一个<code class="language-plaintext highlighter-rouge">pair</code>，两个类型分别为<code class="language-plaintext highlighter-rouge">T1</code>和<code class="language-plaintext highlighter-rouge">T2</code>的成员都进行了初始化</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">pair &lt;T1,T2&gt; p(v1,v2)</code></td>
      <td style="text-align: left">p是一个<code class="language-plaintext highlighter-rouge">pair</code>，两个类型分别为<code class="language-plaintext highlighter-rouge">T1</code>和<code class="language-plaintext highlighter-rouge">T2</code>的<code class="language-plaintext highlighter-rouge">v1</code>和<code class="language-plaintext highlighter-rouge">v2</code>都进行了初始化</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">pair &lt;T1,T2&gt; p={v1,v2}</code></td>
      <td style="text-align: left">意义同上</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">make_pair(v1,v2)</code></td>
      <td style="text-align: left">返回一个用<code class="language-plaintext highlighter-rouge">v1</code>,<code class="language-plaintext highlighter-rouge">v2</code>初始化的<code class="language-plaintext highlighter-rouge">pair</code>。<code class="language-plaintext highlighter-rouge">pair</code>的类型从<code class="language-plaintext highlighter-rouge">v1</code>和<code class="language-plaintext highlighter-rouge">v2</code>的类型中推断出来</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">p.first</code></td>
      <td style="text-align: left">返回<code class="language-plaintext highlighter-rouge">p</code>的名称为<code class="language-plaintext highlighter-rouge">first</code>的公有数据成员</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">p1 relop p2</code></td>
      <td style="text-align: left">关系运算符(&lt;、&gt;、&lt;=、&gt;=)按照字典序定义：例如对应成立时返回<code class="language-plaintext highlighter-rouge">true</code></td>
    </tr>
  </tbody>
</table>

<h3 id="113-关联容器操作">11.3 关联容器操作</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作类型</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">key_type</code></td>
      <td style="text-align: left">此容器类型的关键字类型</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">mapped_type</code></td>
      <td style="text-align: left">每个关键字关联的类型；只适用于<code class="language-plaintext highlighter-rouge">map</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">value_type</code></td>
      <td style="text-align: left">对于<code class="language-plaintext highlighter-rouge">set</code>,与<code class="language-plaintext highlighter-rouge">key_type</code>相同；对于<code class="language-plaintext highlighter-rouge">map</code>，为<code class="language-plaintext highlighter-rouge">pair&lt;const key_type,mapped_type&gt;</code></td>
    </tr>
  </tbody>
</table>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">v1</span><span class="p">;</span> <span class="c1">//v1是一个string</span>

<span class="n">set</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">key_type</span> <span class="n">v2</span><span class="p">;</span> <span class="c1">//v2是一个string</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="n">v3</span><span class="p">;</span><span class="c1">//v3是一个pair &lt;const string ,int&gt;</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">key_type</span> <span class="n">v4</span><span class="p">;</span> <span class="c1">//v4是一个string</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">mapped_type</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">//v5是一个int</span>

</code></pre></div></div>
<p>注意：</p>

<ul>
  <li>一个<code class="language-plaintext highlighter-rouge">map</code>的<code class="language-plaintext highlighter-rouge">value_type</code>是一个<code class="language-plaintext highlighter-rouge">pair</code>,我们可以改变<code class="language-plaintext highlighter-rouge">pair</code>的值，但不能改变关键字成员的值。</li>
  <li><code class="language-plaintext highlighter-rouge">set</code>的迭代器是<code class="language-plaintext highlighter-rouge">const</code>的，只能读取，不能修改。</li>
</ul>

<h4 id="1131-关联容器迭代器">11.3.1 关联容器迭代器</h4>
<p>使用示例：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">map_it</span><span class="o">=</span><span class="n">word_count</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>  <span class="c1">//*map_it 是一个指向pair&lt;const string,size_t&gt;对象的引用</span>

<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">map_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span> <span class="c1">//打印此元素的关键字</span>

<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="s">""</span><span class="o">&lt;&lt;</span><span class="n">map_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">//打印此元素的值</span>

<span class="n">map_it</span><span class="o">-&gt;</span><span class="n">first</span><span class="o">=</span><span class="s">"new key"</span><span class="p">;</span> <span class="c1">//错误：关键字是const的</span>

<span class="o">++</span><span class="n">map_it</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">//正确：我们可以通过迭代器改变元素</span>

</code></pre></div></div>
<p>因为关联容器<code class="language-plaintext highlighter-rouge">set</code>的迭代元素是<code class="language-plaintext highlighter-rouge">const</code>的，<code class="language-plaintext highlighter-rouge">map</code>中的元素是<code class="language-plaintext highlighter-rouge">pair</code>，其第一个成员是<code class="language-plaintext highlighter-rouge">const</code>的，因此关联容器，通常用于值读取元素的算法,多为搜索排序。
同时使用<code class="language-plaintext highlighter-rouge">insert</code>来添加元素</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">ivec</span><span class="o">=</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">};</span><span class="c1">//ivec有8个元素</span>

<span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">set2</span><span class="p">;</span> <span class="c1">//空集合</span>

<span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">ivec</span><span class="p">.</span><span class="n">cbegin</span><span class="p">(),</span><span class="n">ivec</span><span class="p">.</span><span class="n">cend</span><span class="p">());</span><span class="c1">//set2有4个元素</span>

<span class="n">set2</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">});</span><span class="c1">//set2现在有8个元素</span>

</code></pre></div></div>
<p>关联容器操作：
<code class="language-plaintext highlighter-rouge">emplace(args)</code>:对于<code class="language-plaintext highlighter-rouge">map</code>和<code class="language-plaintext highlighter-rouge">set</code>,只有当元素的关键字不在<code class="language-plaintext highlighter-rouge">c</code>中时才插入(或者构造)元素。函数返回一个<code class="language-plaintext highlighter-rouge">pair</code>,包含一个迭代器，指向具体有指定关键字的元素，以及一个指示插入是否成功的bool值。</p>

<p>注意插入操作返回的是一个<code class="language-plaintext highlighter-rouge">pair</code>对象，第一个元素是差诶迭代器的坐标，第二个值是一个<code class="language-plaintext highlighter-rouge">bool</code>值，确定是否插入成功。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//统计每个单词在输入中出现的次数</span>

<span class="n">map</span><span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span><span class="c1">//从string到size_t的空map</span>

<span class="n">string</span> <span class="n">word</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">cin</span><span class="o">&gt;&gt;</span><span class="n">word</span><span class="p">){</span>
    <span class="c1">//插入一个元素，关键字等于word，值为1；</span>
    <span class="c1">//若word已载word_count中，insert什么也不做</span>
    <span class="k">auto</span> <span class="n">ret</span><span class="o">=</span><span class="n">word_count</span><span class="p">.</span><span class="n">insert</span><span class="p">({</span><span class="n">word</span><span class="p">,</span><span class="mi">1</span><span class="p">});</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>  <span class="c1">//word已经在word_count中</span>

        <span class="o">++</span><span class="n">ret</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span> <span class="c1">//递增计数器</span>

<span class="cm">/*

等价形式 ++((ret.first)-&gt;second);
ret 保存insert返回的值，是一个pair
ret.first 是pair的第一个成员，是一个map迭代器，指向具有给定关键字的元素
ret.first-&gt; 解引用此迭代器，提取map中的元素，元素也是一个pair
ret.first-&gt;second; map中元素值的部分
++ ret.first-&gt;second; 递增此值
*/</span>
<span class="p">}</span>
</code></pre></div></div>
<h4 id="1133-删除元素">11.3.3 删除元素</h4>
<p>使用<code class="language-plaintext highlighter-rouge">erase</code>函数来删除和释放元素;</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">cnt</span><span class="o">=</span><span class="n">authors</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="s">"Barth,Johns"</span><span class="p">);</span>
</code></pre></div></div>

<h4 id="1134-map的下表操作">11.3.4 map的下表操作</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c[k]</code></td>
      <td style="text-align: left">返回关键字为<code class="language-plaintext highlighter-rouge">k</code>的元素；如果<code class="language-plaintext highlighter-rouge">k</code>不在<code class="language-plaintext highlighter-rouge">c</code>中，添加一个关键字为<code class="language-plaintext highlighter-rouge">k</code>的元素，对其进行值初试化</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.at(k)</code></td>
      <td style="text-align: left">访问管家字为<code class="language-plaintext highlighter-rouge">k</code>的元素</td>
    </tr>
  </tbody>
</table>

<p>示例：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">map</span> <span class="o">&lt;</span><span class="n">string</span> <span class="p">,</span><span class="kt">size_t</span><span class="o">&gt;</span> <span class="n">word_count</span><span class="p">;</span> <span class="c1">//empty map</span>

<span class="c1">//插入一个关键字为Anna的元素，关联值进行值初试化；然后将1赋予它</span>

<span class="n">word_count</span><span class="p">[</span><span class="s">"Anna"</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

</code></pre></div></div>
<p>注意：</p>

<ul>
  <li>对一个<code class="language-plaintext highlighter-rouge">map</code>使用下表操作，使用一个不在容器中的关键字作为下表，会添加一个具有此关键字的元素到<code class="language-plaintext highlighter-rouge">map</code>中</li>
  <li>与<code class="language-plaintext highlighter-rouge">vector</code>与<code class="language-plaintext highlighter-rouge">string</code>不同，<code class="language-plaintext highlighter-rouge">map</code>的下标运算符，返回的类型与解引用<code class="language-plaintext highlighter-rouge">map</code>迭代器得到的类型不同。</li>
  <li><code class="language-plaintext highlighter-rouge">map</code>使用<code class="language-plaintext highlighter-rouge">find</code>代替下标操作</li>
  <li><code class="language-plaintext highlighter-rouge">lower_bound</code>和<code class="language-plaintext highlighter-rouge">upper_bound</code>不适用于无序容器</li>
  <li>下标和<code class="language-plaintext highlighter-rouge">at</code>操作只适用于非<code class="language-plaintext highlighter-rouge">const</code>的<code class="language-plaintext highlighter-rouge">map</code>和<code class="language-plaintext highlighter-rouge">unordered_map</code></li>
</ul>

<p><strong>关联容器中查找元素的操作</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.find(k)</code></td>
      <td style="text-align: left">返回一个迭代器，指向第一个关键字为<code class="language-plaintext highlighter-rouge">k</code>的元素，若<code class="language-plaintext highlighter-rouge">k</code>不在容器中则返回尾后迭代器</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.count(k)</code></td>
      <td style="text-align: left">返回关键字等于<code class="language-plaintext highlighter-rouge">k</code>的元素的数量。对于不允许重复关键字的容器，返回值永远是0或者1</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.lower_bound(k)</code></td>
      <td style="text-align: left">返回一个迭代器，指向第一个关键字不小于<code class="language-plaintext highlighter-rouge">k</code>的元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.upper_bound(k)</code></td>
      <td style="text-align: left">返回一个迭代器，指向第一个关键字不大于<code class="language-plaintext highlighter-rouge">k</code>的元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.equal_range(k)</code></td>
      <td style="text-align: left">返回一个迭代器<code class="language-plaintext highlighter-rouge">pair</code>，指向第一个关键字等于<code class="language-plaintext highlighter-rouge">k</code>的元素</td>
    </tr>
  </tbody>
</table>

<p>注意：</p>

<ul>
  <li>当我们遍历一个<code class="language-plaintext highlighter-rouge">multimap</code>或者<code class="language-plaintext highlighter-rouge">multiset</code>时，保证可以得到序列中所有具有给定关键字的元素。</li>
  <li><code class="language-plaintext highlighter-rouge">lower_bound</code>返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则<code class="language-plaintext highlighter-rouge">lower_bound</code>会返回关键字的第一个安全插入点–不影响容器中元素顺序的插入位置。</li>
  <li>如果<code class="language-plaintext highlighter-rouge">lower_bound</code>和<code class="language-plaintext highlighter-rouge">upper_bound</code>返回相同的迭代器，则给定关键字不在容器中。</li>
</ul>

<h3 id="114-无序容器">11.4 无序容器</h3>
<p>无序关联容器总共有4个：<code class="language-plaintext highlighter-rouge">unordered_map</code>和<code class="language-plaintext highlighter-rouge">unordered_set</code>;</p>

<p><strong>桶管理</strong>
无序容器在存储组织上为一组桶，每个桶保存0个或者多个元素。无序容器使用一个哈希函数将元素映射到桶。</p>

<p><strong>无序容器管理操作</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">操作</th>
      <th style="text-align: left">含义</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">**桶接口**</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.bucket_count()</code></td>
      <td style="text-align: left">正在使用的桶的数目</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.max_bucket_count()</code></td>
      <td style="text-align: left">容器能容纳的最多的桶的数量</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.bucket_size(n)</code></td>
      <td style="text-align: left">第n个桶中有多少个元素</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.bucket(k)</code></td>
      <td style="text-align: left">关键字为<code class="language-plaintext highlighter-rouge">k</code>的元素在那个桶中</td>
    </tr>
    <tr>
      <td style="text-align: left">**桶迭代**|</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">local_iterator</code></td>
      <td style="text-align: left">可以用来访问桶中元素的迭代器类型</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">const_local_iterator</code></td>
      <td style="text-align: left">桶迭代器的<code class="language-plaintext highlighter-rouge">const</code>版本</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.begin(n),c.end(n)</code></td>
      <td style="text-align: left">与前两个函数类似，但返回<code class="language-plaintext highlighter-rouge">const_local_iterator</code></td>
    </tr>
    <tr>
      <td style="text-align: left">**哈希策略**|</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.load_factor()</code></td>
      <td style="text-align: left">每个桶的平均元素数量。返回<code class="language-plaintext highlighter-rouge">float</code>值</td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.max_load_factor()</code></td>
      <td style="text-align: left">c维护桶的大小，返回<code class="language-plaintext highlighter-rouge">float</code>值。c会在需要时添加新的桶。以使得<code class="language-plaintext highlighter-rouge">load_factor&lt;=max_load_factor</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.rehash(n)</code></td>
      <td style="text-align: left">重组存储，使得<code class="language-plaintext highlighter-rouge">bucket_count&gt;=n</code>且<code class="language-plaintext highlighter-rouge">bucket_count&gt;size/max_load_factor</code></td>
    </tr>
    <tr>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">c.reserve(n)</code></td>
      <td style="text-align: left">重组存储，使得c可以保存<code class="language-plaintext highlighter-rouge">n</code>个元素且不必<code class="language-plaintext highlighter-rouge">rehash</code></td>
    </tr>
  </tbody>
</table>

:ET